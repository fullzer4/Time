'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetMock = exports.getAllMocks = exports.getAllAsyncMocks = exports.getAsyncMock = exports.getMock = exports.insertMock = exports.getAsyncModuleName = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _path = require('path');

var _pathParse = require('path-parse');

var _pathParse2 = _interopRequireDefault(_pathParse);

var _globals = require('./globals');

var _globals2 = _interopRequireDefault(_globals);

var _constants = require('./constants');

var _module = require('./module');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var genMock = function genMock(name) {
  return {
    name: name,
    value: {}
  };
};

var insertMock = function insertMock(name, mock) {
  return (0, _globals2.default)().mocks[name] = mock;
};
var resetMock = function resetMock(name) {
  return insertMock(name, genMock(name));
};

var pickFrom = function pickFrom(mocks, name) {
  var ext = (0, _constants.getExtensions)().filter(function (ext) {
    return mocks.hasOwnProperty(name + ext);
  }).shift();
  if (ext !== undefined) {
    return mocks[name + ext];
  }
};

var getMock = function getMock(name) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _globals2.default)();
  var mocks = scope.mocks;

  var fn = (0, _pathParse2.default)(name);
  var shortName = (0, _path.join)(fn.dir, fn.name);
  var wshortName = fn.dir + '/' + fn.name;
  var indexName = fn.name === 'index' ? fn.dir : null;

  var mock = pickFrom(mocks, name) || indexName && pickFrom(mocks, indexName) || pickFrom(mocks, shortName) || pickFrom(mocks, wshortName);

  if (!mock && scope.parentScope) {
    return getMock(name, scope.parentScope);
  }
  return mock;
};

var getAsyncModuleName = exports.getAsyncModuleName = function getAsyncModuleName(creator, parent) {
  return creator.toString() + ':' + (0, _module.getModuleName)(parent);
};

var getAsyncMock = function getAsyncMock(creator, parent) {
  var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _globals2.default)();

  var signature = getAsyncModuleName(creator, parent);
  var mock = resetMock(signature);
  scope.asyncMocks.push({
    mock: mock,
    creator: creator,
    loaded: false
  });
  return mock;
};

var collectMocks = function collectMocks(result, selector) {
  var collect = function collect(scope) {
    if (scope.parentScope) {
      collect(scope.parentScope);
    }
    var mocks = selector(scope);
    (0, _keys2.default)(mocks).forEach(function (key) {
      return result[key] = mocks[key];
    });
  };
  collect((0, _globals2.default)());
  return result;
};

var getAllMocks = function getAllMocks() {
  return collectMocks({}, function (scope) {
    return scope.mocks;
  });
};

var getAllAsyncMocks = function getAllAsyncMocks() {
  return collectMocks([], function (scope) {
    return scope.asyncMocks.filter(function (mock) {
      return !mock.loaded;
    });
  }).filter(function (mock) {
    return !!mock;
  });
};

exports.insertMock = insertMock;
exports.getMock = getMock;
exports.getAsyncMock = getAsyncMock;
exports.getAllAsyncMocks = getAllAsyncMocks;
exports.getAllMocks = getAllMocks;
exports.resetMock = resetMock;