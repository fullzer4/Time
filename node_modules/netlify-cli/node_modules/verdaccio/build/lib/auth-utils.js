"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.allow_action = allow_action;
exports.buildUserBuffer = buildUserBuffer;
exports.createAnonymousRemoteUser = createAnonymousRemoteUser;
exports.createRemoteUser = createRemoteUser;
exports.createSessionToken = createSessionToken;
exports.expireReasons = exports.defaultUserRateLimiting = exports.defaultSecurity = void 0;
exports.getApiToken = getApiToken;
exports.getAuthenticatedMessage = getAuthenticatedMessage;
exports.getDefaultPlugins = getDefaultPlugins;
exports.getMiddlewareCredentials = getMiddlewareCredentials;
exports.getSecurity = getSecurity;
exports.handleSpecialUnpublish = handleSpecialUnpublish;
exports.isAESLegacy = isAESLegacy;
exports.isAuthHeaderValid = isAuthHeaderValid;
exports.parseAESCredentials = parseAESCredentials;
exports.parseAuthTokenHeader = parseAuthTokenHeader;
exports.parseBasicPayload = parseBasicPayload;
exports.validatePassword = validatePassword;
exports.verifyJWTPayload = verifyJWTPayload;

var _debug = _interopRequireDefault(require("debug"));

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = require("../lib/logger");

var _constants = require("./constants");

var _cryptoUtils = require("./crypto-utils");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug.default)('verdaccio');

function validatePassword(password, // pragma: allowlist secret
minLength = _constants.DEFAULT_MIN_LIMIT_PASSWORD) {
  return typeof password === 'string' && password.length >= minLength;
}
/**
 * Create a RemoteUser object
 * @return {Object} { name: xx, pluginGroups: [], real_groups: [] }
 */


function createRemoteUser(name, pluginGroups) {
  const isGroupValid = Array.isArray(pluginGroups);
  const groups = Array.from(new Set((isGroupValid ? pluginGroups : []).concat([_constants.ROLES.$ALL, _constants.ROLES.$AUTH, _constants.ROLES.DEPRECATED_ALL, _constants.ROLES.DEPRECATED_AUTH, _constants.ROLES.ALL])));
  return {
    name,
    groups,
    real_groups: pluginGroups
  };
}
/**
 * Builds an anonymous remote user in case none is logged in.
 * @return {Object} { name: xx, groups: [], real_groups: [] }
 */


function createAnonymousRemoteUser() {
  return {
    name: undefined,
    // groups without '$' are going to be deprecated eventually
    groups: [_constants.ROLES.$ALL, _constants.ROLES.$ANONYMOUS, _constants.ROLES.DEPRECATED_ALL, _constants.ROLES.DEPRECATED_ANONYMOUS],
    real_groups: []
  };
}

function allow_action(action) {
  return function (user, pkg, callback) {
    debug('[auth/allow_action]: user: %o', user === null || user === void 0 ? void 0 : user.name);
    const {
      name,
      groups
    } = user;
    const groupAccess = pkg[action];
    const hasPermission = groupAccess.some(group => name === group || groups.includes(group));
    debug('[auth/allow_action]: hasPermission? %o} for user: %o', hasPermission, user === null || user === void 0 ? void 0 : user.name);

    if (hasPermission) {
      _logger.logger.info({
        remote: user.name
      }, `auth/allow_action: access granted to: @{user}`);

      return callback(null, true);
    }

    if (name) {
      callback(_utils.ErrorCode.getForbidden(`user ${name} is not allowed to ${action} package ${pkg.name}`));
    } else {
      callback(_utils.ErrorCode.getUnauthorized(`authorization required to ${action} package ${pkg.name}`));
    }
  };
}
/**
 *
 */


function handleSpecialUnpublish() {
  return function (user, pkg, callback) {
    const action = 'unpublish'; // verify whether the unpublish prop has been defined

    const isUnpublishMissing = _lodash.default.isNil(pkg[action]);

    const hasGroups = isUnpublishMissing ? false : pkg[action].length > 0;
    debug('fallback unpublish for @{name} has groups: %o for %o', hasGroups, user === null || user === void 0 ? void 0 : user.name);

    if (isUnpublishMissing || hasGroups === false) {
      return callback(null, undefined);
    }

    debug('allow_action for %o for %o has groups: %o for %o', action, user === null || user === void 0 ? void 0 : user.name, hasGroups, user);
    return allow_action(action)(user, pkg, callback);
  };
}

function getDefaultPlugins(logger) {
  return {
    authenticate(_user, _password, cb) {
      // pragma: allowlist secret
      cb(_utils.ErrorCode.getForbidden(_constants.API_ERROR.BAD_USERNAME_PASSWORD));
    },

    add_user(_user, _password, cb) {
      // pragma: allowlist secret
      return cb(_utils.ErrorCode.getConflict(_constants.API_ERROR.BAD_USERNAME_PASSWORD));
    },

    // FIXME: allow_action and allow_publish should be in the @verdaccio/types
    // @ts-ignore
    allow_access: allow_action('access', logger),
    // @ts-ignore
    allow_publish: allow_action('publish', logger),
    allow_unpublish: handleSpecialUnpublish()
  };
}

function createSessionToken() {
  const tenHoursTime = 10 * 60 * 60 * 1000;
  return {
    // npmjs.org sets 10h expire
    expires: new Date(Date.now() + tenHoursTime)
  };
}

const defaultWebTokenOptions = {
  sign: {
    // The expiration token for the website is 1 hour
    expiresIn: _constants.TIME_EXPIRATION_1H
  },
  verify: {}
};
const defaultApiTokenConf = {
  legacy: true
}; // we limit max 1000 request per 15 minutes on user endpoints

const defaultUserRateLimiting = {
  windowMs: 15 * 60 * 1000,
  // 15 minutes
  max: 1000
};
exports.defaultUserRateLimiting = defaultUserRateLimiting;
const defaultSecurity = {
  web: defaultWebTokenOptions,
  api: defaultApiTokenConf
};
exports.defaultSecurity = defaultSecurity;

function getSecurity(config) {
  if (_lodash.default.isNil(config.security) === false) {
    return _lodash.default.merge(defaultSecurity, config.security);
  }

  return defaultSecurity;
}

function getAuthenticatedMessage(user) {
  return `you are authenticated as '${user}'`;
}

function buildUserBuffer(name, password) {
  return Buffer.from(`${name}:${password}`, 'utf8');
}

function isAESLegacy(security) {
  const {
    legacy,
    jwt
  } = security.api;
  return _lodash.default.isNil(legacy) === false && _lodash.default.isNil(jwt) && legacy === true;
}

async function getApiToken(auth, config, remoteUser, aesPassword) {
  const security = getSecurity(config);

  if (isAESLegacy(security)) {
    // fallback all goes to AES encryption
    return await new Promise(resolve => {
      resolve(auth.aesEncrypt(buildUserBuffer(remoteUser.name, aesPassword)).toString('base64'));
    });
  } // i am wiling to use here _.isNil but flow does not like it yet.


  const {
    jwt
  } = security.api;

  if (jwt && jwt.sign) {
    return await auth.jwtEncrypt(remoteUser, jwt.sign);
  }

  return await new Promise(resolve => {
    resolve(auth.aesEncrypt(buildUserBuffer(remoteUser.name, aesPassword)).toString('base64'));
  });
}

function parseAuthTokenHeader(authorizationHeader) {
  const parts = authorizationHeader.split(' ');
  const [scheme, token] = parts;
  return {
    scheme,
    token
  };
}

function parseBasicPayload(credentials) {
  const index = credentials.indexOf(':');

  if (index < 0) {
    return;
  }

  const user = credentials.slice(0, index);
  const password = credentials.slice(index + 1);
  return {
    user,
    password
  };
}

function parseAESCredentials(authorizationHeader, secret) {
  const {
    scheme,
    token
  } = parseAuthTokenHeader(authorizationHeader); // basic is deprecated and should not be enforced

  if (scheme.toUpperCase() === _constants.TOKEN_BASIC.toUpperCase()) {
    const credentials = (0, _utils.convertPayloadToBase64)(token).toString();
    return credentials;
  } else if (scheme.toUpperCase() === _constants.TOKEN_BEARER.toUpperCase()) {
    const tokenAsBuffer = (0, _utils.convertPayloadToBase64)(token);
    const credentials = (0, _cryptoUtils.aesDecrypt)(tokenAsBuffer, secret).toString('utf8');
    return credentials;
  }
}

const expireReasons = ['JsonWebTokenError', 'TokenExpiredError'];
exports.expireReasons = expireReasons;

function verifyJWTPayload(token, secret) {
  try {
    const payload = (0, _cryptoUtils.verifyPayload)(token, secret);
    return payload;
  } catch (error) {
    // #168 this check should be removed as soon AES encrypt is removed.
    if (expireReasons.includes(error.name)) {
      // it might be possible the jwt configuration is enabled and
      // old tokens fails still remains in usage, thus
      // we return an anonymous user to force log in.
      return createAnonymousRemoteUser();
    }

    throw _utils.ErrorCode.getCode(_constants.HTTP_STATUS.UNAUTHORIZED, error.message);
  }
}

function isAuthHeaderValid(authorization) {
  return authorization.split(' ').length === 2;
}

function getMiddlewareCredentials(security, secret, authorizationHeader) {
  if (isAESLegacy(security)) {
    const credentials = parseAESCredentials(authorizationHeader, secret);

    if (!credentials) {
      return;
    }

    const parsedCredentials = parseBasicPayload(credentials);

    if (!parsedCredentials) {
      return;
    }

    return parsedCredentials;
  }

  const {
    scheme,
    token
  } = parseAuthTokenHeader(authorizationHeader);

  if (_lodash.default.isString(token) && scheme.toUpperCase() === _constants.TOKEN_BEARER.toUpperCase()) {
    return verifyJWTPayload(token, secret);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsInZhbGlkYXRlUGFzc3dvcmQiLCJwYXNzd29yZCIsIm1pbkxlbmd0aCIsIkRFRkFVTFRfTUlOX0xJTUlUX1BBU1NXT1JEIiwibGVuZ3RoIiwiY3JlYXRlUmVtb3RlVXNlciIsIm5hbWUiLCJwbHVnaW5Hcm91cHMiLCJpc0dyb3VwVmFsaWQiLCJBcnJheSIsImlzQXJyYXkiLCJncm91cHMiLCJmcm9tIiwiU2V0IiwiY29uY2F0IiwiUk9MRVMiLCIkQUxMIiwiJEFVVEgiLCJERVBSRUNBVEVEX0FMTCIsIkRFUFJFQ0FURURfQVVUSCIsIkFMTCIsInJlYWxfZ3JvdXBzIiwiY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlciIsInVuZGVmaW5lZCIsIiRBTk9OWU1PVVMiLCJERVBSRUNBVEVEX0FOT05ZTU9VUyIsImFsbG93X2FjdGlvbiIsImFjdGlvbiIsInVzZXIiLCJwa2ciLCJjYWxsYmFjayIsImdyb3VwQWNjZXNzIiwiaGFzUGVybWlzc2lvbiIsInNvbWUiLCJncm91cCIsImluY2x1ZGVzIiwibG9nZ2VyIiwiaW5mbyIsInJlbW90ZSIsIkVycm9yQ29kZSIsImdldEZvcmJpZGRlbiIsImdldFVuYXV0aG9yaXplZCIsImhhbmRsZVNwZWNpYWxVbnB1Ymxpc2giLCJpc1VucHVibGlzaE1pc3NpbmciLCJfIiwiaXNOaWwiLCJoYXNHcm91cHMiLCJnZXREZWZhdWx0UGx1Z2lucyIsImF1dGhlbnRpY2F0ZSIsIl91c2VyIiwiX3Bhc3N3b3JkIiwiY2IiLCJBUElfRVJST1IiLCJCQURfVVNFUk5BTUVfUEFTU1dPUkQiLCJhZGRfdXNlciIsImdldENvbmZsaWN0IiwiYWxsb3dfYWNjZXNzIiwiYWxsb3dfcHVibGlzaCIsImFsbG93X3VucHVibGlzaCIsImNyZWF0ZVNlc3Npb25Ub2tlbiIsInRlbkhvdXJzVGltZSIsImV4cGlyZXMiLCJEYXRlIiwibm93IiwiZGVmYXVsdFdlYlRva2VuT3B0aW9ucyIsInNpZ24iLCJleHBpcmVzSW4iLCJUSU1FX0VYUElSQVRJT05fMUgiLCJ2ZXJpZnkiLCJkZWZhdWx0QXBpVG9rZW5Db25mIiwibGVnYWN5IiwiZGVmYXVsdFVzZXJSYXRlTGltaXRpbmciLCJ3aW5kb3dNcyIsIm1heCIsImRlZmF1bHRTZWN1cml0eSIsIndlYiIsImFwaSIsImdldFNlY3VyaXR5IiwiY29uZmlnIiwic2VjdXJpdHkiLCJtZXJnZSIsImdldEF1dGhlbnRpY2F0ZWRNZXNzYWdlIiwiYnVpbGRVc2VyQnVmZmVyIiwiQnVmZmVyIiwiaXNBRVNMZWdhY3kiLCJqd3QiLCJnZXRBcGlUb2tlbiIsImF1dGgiLCJyZW1vdGVVc2VyIiwiYWVzUGFzc3dvcmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImFlc0VuY3J5cHQiLCJ0b1N0cmluZyIsImp3dEVuY3J5cHQiLCJwYXJzZUF1dGhUb2tlbkhlYWRlciIsImF1dGhvcml6YXRpb25IZWFkZXIiLCJwYXJ0cyIsInNwbGl0Iiwic2NoZW1lIiwidG9rZW4iLCJwYXJzZUJhc2ljUGF5bG9hZCIsImNyZWRlbnRpYWxzIiwiaW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJwYXJzZUFFU0NyZWRlbnRpYWxzIiwic2VjcmV0IiwidG9VcHBlckNhc2UiLCJUT0tFTl9CQVNJQyIsIlRPS0VOX0JFQVJFUiIsInRva2VuQXNCdWZmZXIiLCJleHBpcmVSZWFzb25zIiwidmVyaWZ5SldUUGF5bG9hZCIsInBheWxvYWQiLCJlcnJvciIsImdldENvZGUiLCJIVFRQX1NUQVRVUyIsIlVOQVVUSE9SSVpFRCIsIm1lc3NhZ2UiLCJpc0F1dGhIZWFkZXJWYWxpZCIsImF1dGhvcml6YXRpb24iLCJnZXRNaWRkbGV3YXJlQ3JlZGVudGlhbHMiLCJwYXJzZWRDcmVkZW50aWFscyIsImlzU3RyaW5nIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9hdXRoLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBidWlsZERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7IEFQSVRva2VuT3B0aW9ucywgQ2FsbGJhY2ssIENvbmZpZywgSVBsdWdpbkF1dGgsIEpXVE9wdGlvbnMsIFBhY2thZ2UsIFJlbW90ZVVzZXIsIFNlY3VyaXR5IH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5cbmltcG9ydCB7IEF1dGhNaWRkbGV3YXJlUGF5bG9hZCwgQXV0aFRva2VuSGVhZGVyLCBCYXNpY1BheWxvYWQsIENvb2tpZVNlc3Npb25Ub2tlbiwgSUF1dGhXZWJVSSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgQVBJX0VSUk9SLCBERUZBVUxUX01JTl9MSU1JVF9QQVNTV09SRCwgSFRUUF9TVEFUVVMsIFJPTEVTLCBUSU1FX0VYUElSQVRJT05fMUgsIFRPS0VOX0JBU0lDLCBUT0tFTl9CRUFSRVIgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBhZXNEZWNyeXB0LCB2ZXJpZnlQYXlsb2FkIH0gZnJvbSAnLi9jcnlwdG8tdXRpbHMnO1xuaW1wb3J0IHsgRXJyb3JDb2RlLCBjb252ZXJ0UGF5bG9hZFRvQmFzZTY0IH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IGRlYnVnID0gYnVpbGREZWJ1ZygndmVyZGFjY2lvJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkKFxuICBwYXNzd29yZDogc3RyaW5nLCAvLyBwcmFnbWE6IGFsbG93bGlzdCBzZWNyZXRcbiAgbWluTGVuZ3RoOiBudW1iZXIgPSBERUZBVUxUX01JTl9MSU1JVF9QQVNTV09SRFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnICYmIHBhc3N3b3JkLmxlbmd0aCA+PSBtaW5MZW5ndGg7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgUmVtb3RlVXNlciBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0geyBuYW1lOiB4eCwgcGx1Z2luR3JvdXBzOiBbXSwgcmVhbF9ncm91cHM6IFtdIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlbW90ZVVzZXIobmFtZTogc3RyaW5nLCBwbHVnaW5Hcm91cHM6IHN0cmluZ1tdKTogUmVtb3RlVXNlciB7XG4gIGNvbnN0IGlzR3JvdXBWYWxpZDogYm9vbGVhbiA9IEFycmF5LmlzQXJyYXkocGx1Z2luR3JvdXBzKTtcbiAgY29uc3QgZ3JvdXBzID0gQXJyYXkuZnJvbShuZXcgU2V0KChpc0dyb3VwVmFsaWQgPyBwbHVnaW5Hcm91cHMgOiBbXSkuY29uY2F0KFtST0xFUy4kQUxMLCBST0xFUy4kQVVUSCwgUk9MRVMuREVQUkVDQVRFRF9BTEwsIFJPTEVTLkRFUFJFQ0FURURfQVVUSCwgUk9MRVMuQUxMXSkpKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgZ3JvdXBzLFxuICAgIHJlYWxfZ3JvdXBzOiBwbHVnaW5Hcm91cHMsXG4gIH07XG59XG5cbi8qKlxuICogQnVpbGRzIGFuIGFub255bW91cyByZW1vdGUgdXNlciBpbiBjYXNlIG5vbmUgaXMgbG9nZ2VkIGluLlxuICogQHJldHVybiB7T2JqZWN0fSB7IG5hbWU6IHh4LCBncm91cHM6IFtdLCByZWFsX2dyb3VwczogW10gfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlcigpOiBSZW1vdGVVc2VyIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgLy8gZ3JvdXBzIHdpdGhvdXQgJyQnIGFyZSBnb2luZyB0byBiZSBkZXByZWNhdGVkIGV2ZW50dWFsbHlcbiAgICBncm91cHM6IFtST0xFUy4kQUxMLCBST0xFUy4kQU5PTllNT1VTLCBST0xFUy5ERVBSRUNBVEVEX0FMTCwgUk9MRVMuREVQUkVDQVRFRF9BTk9OWU1PVVNdLFxuICAgIHJlYWxfZ3JvdXBzOiBbXSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbG93X2FjdGlvbihhY3Rpb246IHN0cmluZyk6IEZ1bmN0aW9uIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh1c2VyOiBSZW1vdGVVc2VyLCBwa2c6IFBhY2thZ2UsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGRlYnVnKCdbYXV0aC9hbGxvd19hY3Rpb25dOiB1c2VyOiAlbycsIHVzZXI/Lm5hbWUpO1xuICAgIGNvbnN0IHsgbmFtZSwgZ3JvdXBzIH0gPSB1c2VyO1xuICAgIGNvbnN0IGdyb3VwQWNjZXNzID0gcGtnW2FjdGlvbl07XG4gICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IGdyb3VwQWNjZXNzLnNvbWUoKGdyb3VwKSA9PiBuYW1lID09PSBncm91cCB8fCBncm91cHMuaW5jbHVkZXMoZ3JvdXApKTtcbiAgICBkZWJ1ZygnW2F1dGgvYWxsb3dfYWN0aW9uXTogaGFzUGVybWlzc2lvbj8gJW99IGZvciB1c2VyOiAlbycsIGhhc1Blcm1pc3Npb24sIHVzZXI/Lm5hbWUpO1xuXG4gICAgaWYgKGhhc1Blcm1pc3Npb24pIHtcbiAgICAgIGxvZ2dlci5pbmZvKHsgcmVtb3RlOiB1c2VyLm5hbWUgfSwgYGF1dGgvYWxsb3dfYWN0aW9uOiBhY2Nlc3MgZ3JhbnRlZCB0bzogQHt1c2VyfWApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBjYWxsYmFjayhFcnJvckNvZGUuZ2V0Rm9yYmlkZGVuKGB1c2VyICR7bmFtZX0gaXMgbm90IGFsbG93ZWQgdG8gJHthY3Rpb259IHBhY2thZ2UgJHtwa2cubmFtZX1gKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKEVycm9yQ29kZS5nZXRVbmF1dGhvcml6ZWQoYGF1dGhvcml6YXRpb24gcmVxdWlyZWQgdG8gJHthY3Rpb259IHBhY2thZ2UgJHtwa2cubmFtZX1gKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVTcGVjaWFsVW5wdWJsaXNoKCk6IGFueSB7XG4gIHJldHVybiBmdW5jdGlvbiAodXNlcjogUmVtb3RlVXNlciwgcGtnOiBQYWNrYWdlLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBhY3Rpb24gPSAndW5wdWJsaXNoJztcbiAgICAvLyB2ZXJpZnkgd2hldGhlciB0aGUgdW5wdWJsaXNoIHByb3AgaGFzIGJlZW4gZGVmaW5lZFxuICAgIGNvbnN0IGlzVW5wdWJsaXNoTWlzc2luZzogYm9vbGVhbiA9IF8uaXNOaWwocGtnW2FjdGlvbl0pO1xuICAgIGNvbnN0IGhhc0dyb3VwczogYm9vbGVhbiA9IGlzVW5wdWJsaXNoTWlzc2luZyA/IGZhbHNlIDogcGtnW2FjdGlvbl0ubGVuZ3RoID4gMDtcbiAgICBkZWJ1ZygnZmFsbGJhY2sgdW5wdWJsaXNoIGZvciBAe25hbWV9IGhhcyBncm91cHM6ICVvIGZvciAlbycsIGhhc0dyb3VwcywgdXNlcj8ubmFtZSk7XG4gICAgaWYgKGlzVW5wdWJsaXNoTWlzc2luZyB8fCBoYXNHcm91cHMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZGVidWcoJ2FsbG93X2FjdGlvbiBmb3IgJW8gZm9yICVvIGhhcyBncm91cHM6ICVvIGZvciAlbycsIGFjdGlvbiwgdXNlcj8ubmFtZSwgaGFzR3JvdXBzLCB1c2VyKTtcbiAgICByZXR1cm4gYWxsb3dfYWN0aW9uKGFjdGlvbikodXNlciwgcGtnLCBjYWxsYmFjayk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UGx1Z2lucyhsb2dnZXI6IGFueSk6IElQbHVnaW5BdXRoPENvbmZpZz4ge1xuICByZXR1cm4ge1xuICAgIGF1dGhlbnRpY2F0ZShfdXNlcjogc3RyaW5nLCBfcGFzc3dvcmQ6IHN0cmluZywgY2I6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgICAvLyBwcmFnbWE6IGFsbG93bGlzdCBzZWNyZXRcbiAgICAgIGNiKEVycm9yQ29kZS5nZXRGb3JiaWRkZW4oQVBJX0VSUk9SLkJBRF9VU0VSTkFNRV9QQVNTV09SRCkpO1xuICAgIH0sXG5cbiAgICBhZGRfdXNlcihfdXNlcjogc3RyaW5nLCBfcGFzc3dvcmQ6IHN0cmluZywgY2I6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgICAvLyBwcmFnbWE6IGFsbG93bGlzdCBzZWNyZXRcbiAgICAgIHJldHVybiBjYihFcnJvckNvZGUuZ2V0Q29uZmxpY3QoQVBJX0VSUk9SLkJBRF9VU0VSTkFNRV9QQVNTV09SRCkpO1xuICAgIH0sXG5cbiAgICAvLyBGSVhNRTogYWxsb3dfYWN0aW9uIGFuZCBhbGxvd19wdWJsaXNoIHNob3VsZCBiZSBpbiB0aGUgQHZlcmRhY2Npby90eXBlc1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhbGxvd19hY2Nlc3M6IGFsbG93X2FjdGlvbignYWNjZXNzJywgbG9nZ2VyKSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWxsb3dfcHVibGlzaDogYWxsb3dfYWN0aW9uKCdwdWJsaXNoJywgbG9nZ2VyKSxcbiAgICBhbGxvd191bnB1Ymxpc2g6IGhhbmRsZVNwZWNpYWxVbnB1Ymxpc2goKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25Ub2tlbigpOiBDb29raWVTZXNzaW9uVG9rZW4ge1xuICBjb25zdCB0ZW5Ib3Vyc1RpbWUgPSAxMCAqIDYwICogNjAgKiAxMDAwO1xuXG4gIHJldHVybiB7XG4gICAgLy8gbnBtanMub3JnIHNldHMgMTBoIGV4cGlyZVxuICAgIGV4cGlyZXM6IG5ldyBEYXRlKERhdGUubm93KCkgKyB0ZW5Ib3Vyc1RpbWUpLFxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0V2ViVG9rZW5PcHRpb25zOiBKV1RPcHRpb25zID0ge1xuICBzaWduOiB7XG4gICAgLy8gVGhlIGV4cGlyYXRpb24gdG9rZW4gZm9yIHRoZSB3ZWJzaXRlIGlzIDEgaG91clxuICAgIGV4cGlyZXNJbjogVElNRV9FWFBJUkFUSU9OXzFILFxuICB9LFxuICB2ZXJpZnk6IHt9LFxufTtcblxuY29uc3QgZGVmYXVsdEFwaVRva2VuQ29uZjogQVBJVG9rZW5PcHRpb25zID0ge1xuICBsZWdhY3k6IHRydWUsXG59O1xuXG4vLyB3ZSBsaW1pdCBtYXggMTAwMCByZXF1ZXN0IHBlciAxNSBtaW51dGVzIG9uIHVzZXIgZW5kcG9pbnRzXG5leHBvcnQgY29uc3QgZGVmYXVsdFVzZXJSYXRlTGltaXRpbmcgPSB7XG4gIHdpbmRvd01zOiAxNSAqIDYwICogMTAwMCwgLy8gMTUgbWludXRlc1xuICBtYXg6IDEwMDAsXG59O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdFNlY3VyaXR5OiBTZWN1cml0eSA9IHtcbiAgd2ViOiBkZWZhdWx0V2ViVG9rZW5PcHRpb25zLFxuICBhcGk6IGRlZmF1bHRBcGlUb2tlbkNvbmYsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VjdXJpdHkoY29uZmlnOiBDb25maWcpOiBTZWN1cml0eSB7XG4gIGlmIChfLmlzTmlsKGNvbmZpZy5zZWN1cml0eSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIF8ubWVyZ2UoZGVmYXVsdFNlY3VyaXR5LCBjb25maWcuc2VjdXJpdHkpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRTZWN1cml0eTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhlbnRpY2F0ZWRNZXNzYWdlKHVzZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgeW91IGFyZSBhdXRoZW50aWNhdGVkIGFzICcke3VzZXJ9J2A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFVzZXJCdWZmZXIobmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogQnVmZmVyIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGAke25hbWV9OiR7cGFzc3dvcmR9YCwgJ3V0ZjgnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQUVTTGVnYWN5KHNlY3VyaXR5OiBTZWN1cml0eSk6IGJvb2xlYW4ge1xuICBjb25zdCB7IGxlZ2FjeSwgand0IH0gPSBzZWN1cml0eS5hcGk7XG5cbiAgcmV0dXJuIF8uaXNOaWwobGVnYWN5KSA9PT0gZmFsc2UgJiYgXy5pc05pbChqd3QpICYmIGxlZ2FjeSA9PT0gdHJ1ZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFwaVRva2VuKGF1dGg6IElBdXRoV2ViVUksIGNvbmZpZzogQ29uZmlnLCByZW1vdGVVc2VyOiBSZW1vdGVVc2VyLCBhZXNQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3Qgc2VjdXJpdHk6IFNlY3VyaXR5ID0gZ2V0U2VjdXJpdHkoY29uZmlnKTtcbiAgaWYgKGlzQUVTTGVnYWN5KHNlY3VyaXR5KSkge1xuICAgIC8vIGZhbGxiYWNrIGFsbCBnb2VzIHRvIEFFUyBlbmNyeXB0aW9uXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKTogdm9pZCA9PiB7XG4gICAgICByZXNvbHZlKGF1dGguYWVzRW5jcnlwdChidWlsZFVzZXJCdWZmZXIocmVtb3RlVXNlci5uYW1lIGFzIHN0cmluZywgYWVzUGFzc3dvcmQpKS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgIH0pO1xuICB9XG4gIC8vIGkgYW0gd2lsaW5nIHRvIHVzZSBoZXJlIF8uaXNOaWwgYnV0IGZsb3cgZG9lcyBub3QgbGlrZSBpdCB5ZXQuXG4gIGNvbnN0IHsgand0IH0gPSBzZWN1cml0eS5hcGk7XG5cbiAgaWYgKGp3dCAmJiBqd3Quc2lnbikge1xuICAgIHJldHVybiBhd2FpdCBhdXRoLmp3dEVuY3J5cHQocmVtb3RlVXNlciwgand0LnNpZ24pO1xuICB9XG4gIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSk6IHZvaWQgPT4ge1xuICAgIHJlc29sdmUoYXV0aC5hZXNFbmNyeXB0KGJ1aWxkVXNlckJ1ZmZlcihyZW1vdGVVc2VyLm5hbWUgYXMgc3RyaW5nLCBhZXNQYXNzd29yZCkpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdXRoVG9rZW5IZWFkZXIoYXV0aG9yaXphdGlvbkhlYWRlcjogc3RyaW5nKTogQXV0aFRva2VuSGVhZGVyIHtcbiAgY29uc3QgcGFydHMgPSBhdXRob3JpemF0aW9uSGVhZGVyLnNwbGl0KCcgJyk7XG4gIGNvbnN0IFtzY2hlbWUsIHRva2VuXSA9IHBhcnRzO1xuXG4gIHJldHVybiB7IHNjaGVtZSwgdG9rZW4gfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQmFzaWNQYXlsb2FkKGNyZWRlbnRpYWxzOiBzdHJpbmcpOiBCYXNpY1BheWxvYWQge1xuICBjb25zdCBpbmRleCA9IGNyZWRlbnRpYWxzLmluZGV4T2YoJzonKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHVzZXI6IHN0cmluZyA9IGNyZWRlbnRpYWxzLnNsaWNlKDAsIGluZGV4KTtcbiAgY29uc3QgcGFzc3dvcmQ6IHN0cmluZyA9IGNyZWRlbnRpYWxzLnNsaWNlKGluZGV4ICsgMSk7XG5cbiAgcmV0dXJuIHsgdXNlciwgcGFzc3dvcmQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQUVTQ3JlZGVudGlhbHMoYXV0aG9yaXphdGlvbkhlYWRlcjogc3RyaW5nLCBzZWNyZXQ6IHN0cmluZykge1xuICBjb25zdCB7IHNjaGVtZSwgdG9rZW4gfSA9IHBhcnNlQXV0aFRva2VuSGVhZGVyKGF1dGhvcml6YXRpb25IZWFkZXIpO1xuXG4gIC8vIGJhc2ljIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgZW5mb3JjZWRcbiAgaWYgKHNjaGVtZS50b1VwcGVyQ2FzZSgpID09PSBUT0tFTl9CQVNJQy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBjb252ZXJ0UGF5bG9hZFRvQmFzZTY0KHRva2VuKS50b1N0cmluZygpO1xuXG4gICAgcmV0dXJuIGNyZWRlbnRpYWxzO1xuICB9IGVsc2UgaWYgKHNjaGVtZS50b1VwcGVyQ2FzZSgpID09PSBUT0tFTl9CRUFSRVIudG9VcHBlckNhc2UoKSkge1xuICAgIGNvbnN0IHRva2VuQXNCdWZmZXIgPSBjb252ZXJ0UGF5bG9hZFRvQmFzZTY0KHRva2VuKTtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGFlc0RlY3J5cHQodG9rZW5Bc0J1ZmZlciwgc2VjcmV0KS50b1N0cmluZygndXRmOCcpO1xuXG4gICAgcmV0dXJuIGNyZWRlbnRpYWxzO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleHBpcmVSZWFzb25zOiBzdHJpbmdbXSA9IFsnSnNvbldlYlRva2VuRXJyb3InLCAnVG9rZW5FeHBpcmVkRXJyb3InXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUpXVFBheWxvYWQodG9rZW46IHN0cmluZywgc2VjcmV0OiBzdHJpbmcpOiBSZW1vdGVVc2VyIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXlsb2FkOiBSZW1vdGVVc2VyID0gdmVyaWZ5UGF5bG9hZCh0b2tlbiwgc2VjcmV0KTtcblxuICAgIHJldHVybiBwYXlsb2FkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vICMxNjggdGhpcyBjaGVjayBzaG91bGQgYmUgcmVtb3ZlZCBhcyBzb29uIEFFUyBlbmNyeXB0IGlzIHJlbW92ZWQuXG4gICAgaWYgKGV4cGlyZVJlYXNvbnMuaW5jbHVkZXMoZXJyb3IubmFtZSkpIHtcbiAgICAgIC8vIGl0IG1pZ2h0IGJlIHBvc3NpYmxlIHRoZSBqd3QgY29uZmlndXJhdGlvbiBpcyBlbmFibGVkIGFuZFxuICAgICAgLy8gb2xkIHRva2VucyBmYWlscyBzdGlsbCByZW1haW5zIGluIHVzYWdlLCB0aHVzXG4gICAgICAvLyB3ZSByZXR1cm4gYW4gYW5vbnltb3VzIHVzZXIgdG8gZm9yY2UgbG9nIGluLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFub255bW91c1JlbW90ZVVzZXIoKTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuVU5BVVRIT1JJWkVELCBlcnJvci5tZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoSGVhZGVyVmFsaWQoYXV0aG9yaXphdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBhdXRob3JpemF0aW9uLnNwbGl0KCcgJykubGVuZ3RoID09PSAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlkZGxld2FyZUNyZWRlbnRpYWxzKHNlY3VyaXR5OiBTZWN1cml0eSwgc2VjcmV0OiBzdHJpbmcsIGF1dGhvcml6YXRpb25IZWFkZXI6IHN0cmluZyk6IEF1dGhNaWRkbGV3YXJlUGF5bG9hZCB7XG4gIGlmIChpc0FFU0xlZ2FjeShzZWN1cml0eSkpIHtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IHBhcnNlQUVTQ3JlZGVudGlhbHMoYXV0aG9yaXphdGlvbkhlYWRlciwgc2VjcmV0KTtcbiAgICBpZiAoIWNyZWRlbnRpYWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkQ3JlZGVudGlhbHMgPSBwYXJzZUJhc2ljUGF5bG9hZChjcmVkZW50aWFscyk7XG4gICAgaWYgKCFwYXJzZWRDcmVkZW50aWFscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRDcmVkZW50aWFscztcbiAgfVxuICBjb25zdCB7IHNjaGVtZSwgdG9rZW4gfSA9IHBhcnNlQXV0aFRva2VuSGVhZGVyKGF1dGhvcml6YXRpb25IZWFkZXIpO1xuXG4gIGlmIChfLmlzU3RyaW5nKHRva2VuKSAmJiBzY2hlbWUudG9VcHBlckNhc2UoKSA9PT0gVE9LRU5fQkVBUkVSLnRvVXBwZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gdmVyaWZ5SldUUGF5bG9hZCh0b2tlbiwgc2VjcmV0KTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxLQUFLLEdBQUcsb0JBQVcsV0FBWCxDQUFkOztBQUVPLFNBQVNDLGdCQUFULENBQ0xDLFFB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