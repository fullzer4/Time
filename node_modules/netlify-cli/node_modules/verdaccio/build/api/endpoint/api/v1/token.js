"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _debug = _interopRequireDefault(require("debug"));

var _express = require("express");

var _lodash = _interopRequireDefault(require("lodash"));

var _authUtils = require("../../../../lib/auth-utils");

var _constants = require("../../../../lib/constants");

var _cryptoUtils = require("../../../../lib/crypto-utils");

var _logger = require("../../../../lib/logger");

var _utils = require("../../../../lib/utils");

var _rateLimiter = require("../../../rate-limiter");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('verdaccio:token');

function normalizeToken(token) {
  return _objectSpread(_objectSpread({}, token), {}, {
    created: new Date(token.created).toISOString()
  });
} // https://github.com/npm/npm-profile/blob/latest/lib/index.js


function _default(auth, storage, config) {
  const tokenRoute = (0, _express.Router)();
  /* eslint new-cap: 0 */

  tokenRoute.get('/tokens', (0, _rateLimiter.limiter)(config === null || config === void 0 ? void 0 : config.userRateLimit), async function (req, res, next) {
    const {
      name
    } = req.remote_user;

    if (_lodash.default.isNil(name) === false) {
      try {
        const tokens = await storage.readTokens({
          user: name
        });
        const totalTokens = tokens.length;
        debug('token list retrieved: %o', totalTokens);
        res.status(_constants.HTTP_STATUS.OK);
        return next({
          objects: tokens.map(normalizeToken),
          urls: {
            next: '' // TODO: pagination?

          }
        });
      } catch (error) {
        _logger.logger.error({
          error: error.msg
        }, 'token list has failed: @{error}');

        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.INTERNAL_ERROR, error.message));
      }
    }

    return next(_utils.ErrorCode.getUnauthorized());
  });
  tokenRoute.post('/tokens', (0, _rateLimiter.limiter)(config === null || config === void 0 ? void 0 : config.userRateLimit), function (req, res, next) {
    const {
      password,
      readonly,
      cidr_whitelist
    } = req.body;
    const {
      name
    } = req.remote_user;

    if (!_lodash.default.isBoolean(readonly) || !_lodash.default.isArray(cidr_whitelist)) {
      return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.BAD_DATA, _constants.SUPPORT_ERRORS.PARAMETERS_NOT_VALID));
    }

    auth.authenticate(name, password, async (err, user) => {
      if (err) {
        const errorCode = err.message ? _constants.HTTP_STATUS.UNAUTHORIZED : _constants.HTTP_STATUS.INTERNAL_ERROR;
        return next(_utils.ErrorCode.getCode(errorCode, err.message));
      }

      req.remote_user = user;

      if (!_lodash.default.isFunction(storage.saveToken)) {
        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.NOT_IMPLEMENTED, _constants.SUPPORT_ERRORS.STORAGE_NOT_IMPLEMENT));
      }

      try {
        const token = await (0, _authUtils.getApiToken)(auth, config, user, password);
        const key = (0, _cryptoUtils.stringToMD5)(token); // TODO: use a utility here

        const maskedToken = (0, _utils.mask)(token, 5);
        const created = new Date().getTime();
        /**
         * cidr_whitelist: is not being used, we pass it through
         * token: we do not store the real token (it is generated once and retrieved to the user), just a mask of it.
         */

        const saveToken = {
          user: name,
          token: maskedToken,
          key,
          cidr: cidr_whitelist,
          readonly,
          created
        };
        await storage.saveToken(saveToken);
        debug('token %o was created for user %o', key, name);
        res.set(_constants.HEADERS.CACHE_CONTROL, 'no-cache, no-store');
        return next(normalizeToken({
          token,
          user: name,
          key: saveToken.key,
          cidr: cidr_whitelist,
          readonly,
          created: saveToken.created
        }));
      } catch (error) {
        _logger.logger.error({
          error: error.msg
        }, 'token creation has failed: @{error}');

        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.INTERNAL_ERROR, error.message));
      }
    });
  });
  tokenRoute.delete('/tokens/token/:tokenKey', (0, _rateLimiter.limiter)(config === null || config === void 0 ? void 0 : config.userRateLimit), async (req, res, next) => {
    const {
      params: {
        tokenKey
      }
    } = req;
    const {
      name
    } = req.remote_user;

    if (_lodash.default.isNil(name) === false) {
      debug('%o has requested remove a token', name);

      try {
        await storage.deleteToken(name, tokenKey);

        _logger.logger.info({
          tokenKey,
          name
        }, 'token id @{tokenKey} was revoked for user @{name}');

        return next({});
      } catch (error) {
        _logger.logger.error({
          error: error.msg
        }, 'token creation has failed: @{error}');

        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.INTERNAL_ERROR, error.message));
      }
    }

    return next(_utils.ErrorCode.getUnauthorized());
  });
  return tokenRoute;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsIm5vcm1hbGl6ZVRva2VuIiwidG9rZW4iLCJjcmVhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiYXV0aCIsInN0b3JhZ2UiLCJjb25maWciLCJ0b2tlblJvdXRlIiwiZ2V0IiwidXNlclJhdGVMaW1pdCIsInJlcSIsInJlcyIsIm5leHQiLCJuYW1lIiwicmVtb3RlX3VzZXIiLCJfIiwiaXNOaWwiLCJ0b2tlbnMiLCJyZWFkVG9rZW5zIiwidXNlciIsInRvdGFsVG9rZW5zIiwibGVuZ3RoIiwic3RhdHVzIiwiSFRUUF9TVEFUVVMiLCJPSyIsIm9iamVjdHMiLCJtYXAiLCJ1cmxzIiwiZXJyb3IiLCJsb2dnZXIiLCJtc2ciLCJFcnJvckNvZGUiLCJnZXRDb2RlIiwiSU5URVJOQUxfRVJST1IiLCJtZXNzYWdlIiwiZ2V0VW5hdXRob3JpemVkIiwicG9zdCIsInBhc3N3b3JkIiwicmVhZG9ubHkiLCJjaWRyX3doaXRlbGlzdCIsImJvZHkiLCJpc0Jvb2xlYW4iLCJpc0FycmF5IiwiQkFEX0RBVEEiLCJTVVBQT1JUX0VSUk9SUyIsIlBBUkFNRVRFUlNfTk9UX1ZBTElEIiwiYXV0aGVudGljYXRlIiwiZXJyIiwiZXJyb3JDb2RlIiwiVU5BVVRIT1JJWkVEIiwiaXNGdW5jdGlvbiIsInNhdmVUb2tlbiIsIk5PVF9JTVBMRU1FTlRFRCIsIlNUT1JBR0VfTk9UX0lNUExFTUVOVCIsImtleSIsIm1hc2tlZFRva2VuIiwiZ2V0VGltZSIsImNpZHIiLCJzZXQiLCJIRUFERVJTIiwiQ0FDSEVfQ09OVFJPTCIsImRlbGV0ZSIsInBhcmFtcyIsInRva2VuS2V5IiwiZGVsZXRlVG9rZW4iLCJpbmZvIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2FwaS9lbmRwb2ludC9hcGkvdjEvdG9rZW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJ1aWxkRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgUmVzcG9uc2UsIFJvdXRlciB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgQ29uZmlnLCBSZW1vdGVVc2VyLCBUb2tlbiB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuXG5pbXBvcnQgeyAkTmV4dEZ1bmN0aW9uVmVyLCAkUmVxdWVzdEV4dGVuZCwgSUF1dGgsIElTdG9yYWdlSGFuZGxlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IGdldEFwaVRva2VuIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2F1dGgtdXRpbHMnO1xuaW1wb3J0IHsgSEVBREVSUywgSFRUUF9TVEFUVVMsIFNVUFBPUlRfRVJST1JTIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzdHJpbmdUb01ENSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9jcnlwdG8tdXRpbHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckNvZGUsIG1hc2sgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHsgbGltaXRlciB9IGZyb20gJy4uLy4uLy4uL3JhdGUtbGltaXRlcic7XG5cbmNvbnN0IGRlYnVnID0gYnVpbGREZWJ1ZygndmVyZGFjY2lvOnRva2VuJyk7XG5leHBvcnQgdHlwZSBOb3JtYWxpemVUb2tlbiA9IFRva2VuICYge1xuICBjcmVhdGVkOiBzdHJpbmc7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVUb2tlbih0b2tlbjogVG9rZW4pOiBOb3JtYWxpemVUb2tlbiB7XG4gIHJldHVybiB7XG4gICAgLi4udG9rZW4sXG4gICAgY3JlYXRlZDogbmV3IERhdGUodG9rZW4uY3JlYXRlZCkudG9JU09TdHJpbmcoKSxcbiAgfTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25wbS9ucG0tcHJvZmlsZS9ibG9iL2xhdGVzdC9saWIvaW5kZXguanNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhdXRoOiBJQXV0aCwgc3RvcmFnZTogSVN0b3JhZ2VIYW5kbGVyLCBjb25maWc6IENvbmZpZyk6IFJvdXRlciB7XG4gIGNvbnN0IHRva2VuUm91dGUgPSBSb3V0ZXIoKTsgLyogZXNsaW50IG5ldy1jYXA6IDAgKi9cbiAgdG9rZW5Sb3V0ZS5nZXQoJy90b2tlbnMnLCBsaW1pdGVyKGNvbmZpZz8udXNlclJhdGVMaW1pdCksIGFzeW5jIGZ1bmN0aW9uIChyZXE6ICRSZXF1ZXN0RXh0ZW5kLCByZXM6IFJlc3BvbnNlLCBuZXh0OiAkTmV4dEZ1bmN0aW9uVmVyKSB7XG4gICAgY29uc3QgeyBuYW1lIH0gPSByZXEucmVtb3RlX3VzZXI7XG5cbiAgICBpZiAoXy5pc05pbChuYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHN0b3JhZ2UucmVhZFRva2Vucyh7IHVzZXI6IG5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHRvdGFsVG9rZW5zID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgZGVidWcoJ3Rva2VuIGxpc3QgcmV0cmlldmVkOiAlbycsIHRvdGFsVG9rZW5zKTtcbiAgICAgICAgcmVzLnN0YXR1cyhIVFRQX1NUQVRVUy5PSyk7XG4gICAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgICBvYmplY3RzOiB0b2tlbnMubWFwKG5vcm1hbGl6ZVRva2VuKSxcbiAgICAgICAgICB1cmxzOiB7XG4gICAgICAgICAgICBuZXh0OiAnJywgLy8gVE9ETzogcGFnaW5hdGlvbj9cbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcih7IGVycm9yOiBlcnJvci5tc2cgfSwgJ3Rva2VuIGxpc3QgaGFzIGZhaWxlZDogQHtlcnJvcn0nKTtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuSU5URVJOQUxfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldFVuYXV0aG9yaXplZCgpKTtcbiAgfSk7XG5cbiAgdG9rZW5Sb3V0ZS5wb3N0KCcvdG9rZW5zJywgbGltaXRlcihjb25maWc/LnVzZXJSYXRlTGltaXQpLCBmdW5jdGlvbiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiBSZXNwb25zZSwgbmV4dDogJE5leHRGdW5jdGlvblZlcikge1xuICAgIGNvbnN0IHsgcGFzc3dvcmQsIHJlYWRvbmx5LCBjaWRyX3doaXRlbGlzdCB9ID0gcmVxLmJvZHk7XG4gICAgY29uc3QgeyBuYW1lIH0gPSByZXEucmVtb3RlX3VzZXI7XG5cbiAgICBpZiAoIV8uaXNCb29sZWFuKHJlYWRvbmx5KSB8fCAhXy5pc0FycmF5KGNpZHJfd2hpdGVsaXN0KSkge1xuICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuQkFEX0RBVEEsIFNVUFBPUlRfRVJST1JTLlBBUkFNRVRFUlNfTk9UX1ZBTElEKSk7XG4gICAgfVxuXG4gICAgYXV0aC5hdXRoZW50aWNhdGUobmFtZSwgcGFzc3dvcmQsIGFzeW5jIChlcnIsIHVzZXI6IFJlbW90ZVVzZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyLm1lc3NhZ2UgPyBIVFRQX1NUQVRVUy5VTkFVVEhPUklaRUQgOiBIVFRQX1NUQVRVUy5JTlRFUk5BTF9FUlJPUjtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldENvZGUoZXJyb3JDb2RlLCBlcnIubWVzc2FnZSkpO1xuICAgICAgfVxuXG4gICAgICByZXEucmVtb3RlX3VzZXIgPSB1c2VyO1xuXG4gICAgICBpZiAoIV8uaXNGdW5jdGlvbihzdG9yYWdlLnNhdmVUb2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuTk9UX0lNUExFTUVOVEVELCBTVVBQT1JUX0VSUk9SUy5TVE9SQUdFX05PVF9JTVBMRU1FTlQpKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRBcGlUb2tlbihhdXRoLCBjb25maWcsIHVzZXIsIHBhc3N3b3JkKTtcbiAgICAgICAgY29uc3Qga2V5ID0gc3RyaW5nVG9NRDUodG9rZW4pO1xuICAgICAgICAvLyBUT0RPOiB1c2UgYSB1dGlsaXR5IGhlcmVcbiAgICAgICAgY29uc3QgbWFza2VkVG9rZW4gPSBtYXNrKHRva2VuLCA1KTtcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaWRyX3doaXRlbGlzdDogaXMgbm90IGJlaW5nIHVzZWQsIHdlIHBhc3MgaXQgdGhyb3VnaFxuICAgICAgICAgKiB0b2tlbjogd2UgZG8gbm90IHN0b3JlIHRoZSByZWFsIHRva2VuIChpdCBpcyBnZW5lcmF0ZWQgb25jZSBhbmQgcmV0cmlldmVkIHRvIHRoZSB1c2VyKSwganVzdCBhIG1hc2sgb2YgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzYXZlVG9rZW46IFRva2VuID0ge1xuICAgICAgICAgIHVzZXI6IG5hbWUsXG4gICAgICAgICAgdG9rZW46IG1hc2tlZFRva2VuLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBjaWRyOiBjaWRyX3doaXRlbGlzdCxcbiAgICAgICAgICByZWFkb25seSxcbiAgICAgICAgICBjcmVhdGVkLFxuICAgICAgICB9O1xuXG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2F2ZVRva2VuKHNhdmVUb2tlbik7XG4gICAgICAgIGRlYnVnKCd0b2tlbiAlbyB3YXMgY3JlYXRlZCBmb3IgdXNlciAlbycsIGtleSwgbmFtZSk7XG4gICAgICAgIHJlcy5zZXQoSEVBREVSUy5DQUNIRV9DT05UUk9MLCAnbm8tY2FjaGUsIG5vLXN0b3JlJyk7XG4gICAgICAgIHJldHVybiBuZXh0KFxuICAgICAgICAgIG5vcm1hbGl6ZVRva2VuKHtcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgdXNlcjogbmFtZSxcbiAgICAgICAgICAgIGtleTogc2F2ZVRva2VuLmtleSxcbiAgICAgICAgICAgIGNpZHI6IGNpZHJfd2hpdGVsaXN0LFxuICAgICAgICAgICAgcmVhZG9ubHksXG4gICAgICAgICAgICBjcmVhdGVkOiBzYXZlVG9rZW4uY3JlYXRlZCxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKHsgZXJyb3I6IGVycm9yLm1zZyB9LCAndG9rZW4gY3JlYXRpb24gaGFzIGZhaWxlZDogQHtlcnJvcn0nKTtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuSU5URVJOQUxfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgdG9rZW5Sb3V0ZS5kZWxldGUoJy90b2tlbnMvdG9rZW4vOnRva2VuS2V5JywgbGltaXRlcihjb25maWc/LnVzZXJSYXRlTGltaXQpLCBhc3luYyAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiBSZXNwb25zZSwgbmV4dDogJE5leHRGdW5jdGlvblZlcikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmFtczogeyB0b2tlbktleSB9LFxuICAgIH0gPSByZXE7XG4gICAgY29uc3QgeyBuYW1lIH0gPSByZXEucmVtb3RlX3VzZXI7XG5cbiAgICBpZiAoXy5pc05pbChuYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgIGRlYnVnKCclbyBoYXMgcmVxdWVzdGVkIHJlbW92ZSBhIHRva2VuJywgbmFtZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzdG9yYWdlLmRlbGV0ZVRva2VuKG5hbWUsIHRva2VuS2V5KTtcbiAgICAgICAgbG9nZ2VyLmluZm8oeyB0b2tlbktleSwgbmFtZSB9LCAndG9rZW4gaWQgQHt0b2tlbktleX0gd2FzIHJldm9rZWQgZm9yIHVzZXIgQHtuYW1lfScpO1xuICAgICAgICByZXR1cm4gbmV4dCh7fSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoeyBlcnJvcjogZXJyb3IubXNnIH0sICd0b2tlbiBjcmVhdGlvbiBoYXMgZmFpbGVkOiBAe2Vycm9yfScpO1xuICAgICAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0Q29kZShIVFRQX1NUQVRVUy5JTlRFUk5BTF9FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0VW5hdXRob3JpemVkKCkpO1xuICB9KTtcblxuICByZXR1cm4gdG9rZW5Sb3V0ZTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUtBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBRUEsTUFBTUEsS0FBSyxHQUFHLG9CQUFXLGlCQUFYLENBQWQ7O0FBS0EsU0FBU0MsY0FBVCxDQUF3QkMsS0FBeEIsRUFBc0Q7RUFDcEQsdUNBQ0tBLEtBREw7SUFFRUMsT0FBTyxFQUFFLElBQUlDLElBQUosQ0FBU0YsS0FBSyxDQUFDQyxPQUFmLEVBQXdCRSxXQUF4QjtFQUZYO0FBSUQsQyxDQUVEOzs7QUFDZSxrQkFBVUMsSUFBVixFQUF1QkMsT0FBdkIsRUFBaURDLE1BQWpELEVBQXlFO0VBQ3RGLE1BQU1DLFVBQVUsR0FBRyxzQkFBbkI7RUFBNkI7O0VBQzdCQSxVQUFVLENBQUNDLEdBQVgsQ0FBZSxTQUFmLEVBQTBCLDBCQUFRRixNQUFSLGFBQVFBLE1BQVIsdUJBQVFBLE1BQU0sQ0FBRUcsYUFBaEIsQ0FBMUIsRUFBMEQsZ0JBQWdCQyxHQUFoQixFQUFxQ0MsR0FBckMsRUFBb0RDLElBQXBELEVBQTRFO0lBQ3BJLE1BQU07TUFBRUM7SUFBRixJQUFXSCxH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