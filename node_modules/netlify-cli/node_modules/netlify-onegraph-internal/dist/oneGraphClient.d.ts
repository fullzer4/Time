import type { CreateNewSchemaMutationInput } from "./generatedOneGraphClient";
/**
 * Given an appId and desired services, fetch the schema (in json form) for that app
 * @param {string} appId
 * @param {string[]} enabledServices
 * @returns {Promise<object>} The schema for the app
 */
export declare const fetchOneGraphSchemaJson: (appId: string, enabledServices: string[]) => Promise<any>;
/**
 * Given an appId and desired services, fetch the schema json for an app and parse it into a GraphQL Schema
 * @param {string} appId
 * @param {string[]} enabledServices
 * @returns {Promise<GraphQLSchema>} The schema for the app
 */
export declare const fetchOneGraphSchema: (appId: string, enabledServices: string[]) => Promise<import("graphql").GraphQLSchema>;
export declare type PersistedQuery = {
    id: string;
    query: string;
    description: string | null;
    allowedOperationNames: string[];
    tags: string[];
};
/**
 * Fetch a persisted doc belonging to appId by its id
 * @param {string} authToken
 * @param {string} appId
 * @param {string} docId
 * @returns {string|undefined} The persisted operations doc
 */
export declare const fetchPersistedQuery: (authToken: string, appId: string, docId: string) => Promise<PersistedQuery | undefined>;
declare type OneGraphCliEvent = Record<string, any>;
/**
 *
 * @param {object} options
 * @param {string} options.appId The app to query against, typically the siteId
 * @param {string} options.authToken The (typically netlify) access token that is used for authentication
 * @param {string} options.sessionId The session id to fetch CLI events for
 * @returns {Promise<{session: OneGraphCliSession , errors: any[]}>} The unhandled events for the cli session to process
 */
export declare const fetchCliSession: (options: {
    appId: string;
    authToken: string;
    sessionId: string;
    desiredEventCount?: number | undefined;
}) => Promise<{
    session: {
        appId: string;
        createdAt: string;
        id: string;
        cliHeartbeatIntervalMs: number;
        events: {
            createdAt: string;
            id: string;
            sessionId: string;
        }[];
        lastEventAt: string;
        metadata: unknown;
        name: string;
        netlifyUserId: string;
    };
    errors: import("./generatedOneGraphClient").GraphQLError[];
}>;
/**
 *
 * @param {object} options
 * @param {string} options.appId The app to query against, typically the siteId
 * @param {string} options.authToken The (typically netlify) access token that is used for authentication
 * @param {string} options.sessionId The session id to fetch CLI events for
 * @returns {Promise<OneGraphCliEvent[]|undefined>} The unhandled events for the cli session to process
 */
export declare const fetchCliSessionEvents: (options: {
    appId: string;
    authToken: string;
    sessionId: string;
}) => Promise<{
    events?: OneGraphCliEvent[] | undefined;
    errors?: any[] | undefined;
} | undefined>;
/**
 * Register a new CLI session with OneGraph
 * @param {string} netlifyToken The netlify token to use for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} name The name of the CLI session, will be visible in the UI and CLI ouputs
 * @param {object} metadata Any additional metadata to attach to the session
 * @returns {Promise<object|undefined>} The CLI session object
 */
export declare const createCLISession: (netlifyToken: string, appId: string, name: string, metadata: Record<string, any>) => Promise<{
    id: string;
    appId: string;
    netlifyUserId: string;
    name: string;
    cliHeartbeatIntervalMs: number;
}>;
/**
 * Update the CLI session with new metadata (e.g. the latest docId) by its id
 * @param {string} netlifyToken The netlify token to use for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} sessionId The session id to update
 * @param {object} metadata The new metadata to set on the session
 * @returns {Promise<object|undefined>} The updated session object
 */
export declare const updateCLISessionMetadata: (netlifyToken: string, appId: string, sessionId: string, metadata: Record<string, any>) => Promise<{
    id: string;
    name: string;
    metadata: unknown;
    cliHeartbeatIntervalMs: number;
}>;
/**
 * Acknoledge CLI events that have been processed and delete them from the upstream queue
 * @param {object} input
 * @param {string} input.appId The app to query against, typically the siteId
 * @param {string} input.authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} input.sessionId The session id the events belong to
 * @param {string[]} input.eventIds The event ids to ack (and delete) from the session queue, having been processed
 * @returns
 */
export declare const ackCLISessionEvents: (input: {
    appId: string;
    authToken: string;
    sessionId: string;
    eventIds: string[];
}) => Promise<{
    events: {
        id: string;
    }[];
}>;
/**
 * Create a persisted operations doc to be later retrieved, usually from a GUI
 * @param {string} netlifyToken The netlify token to use for authentication
 * @param {object} input
 * @param {string} input.appId The app to query against, typically the siteId
 * @param {string} input.document The GraphQL operations document to persist
 * @param {string} input.description A description of the operations doc
 * @param {string[]} input.tags A list of tags to attach to the operations doc
 * @returns
 */
export declare const createPersistedQuery: (netlifyToken: string, { appId, description, document, tags, }: {
    appId: string;
    description: string;
    document: string;
    tags: string[];
}) => Promise<{
    id: string;
}>;
/**
 *
 * @param {OneGraphCliEvent} event
 * @returns {string} a human-friendly description of the event
 */
export declare const friendlyEventName: (event: OneGraphCliEvent) => any;
/**
 * Fetch the schema metadata for a site (enabled services, id, etc.)
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} siteId The site id to query against
 * @returns {Promise<object|undefined>} The schema metadata for the site
 */
export declare const fetchAppSchema: (authToken: string, siteId: string) => Promise<{
    appId: string;
    createdAt: string;
    id: string;
    services: {
        friendlyServiceName: string;
        logoUrl: string;
        service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";
        slug: string;
        supportsCustomRedirectUri: boolean;
        supportsCustomServiceAuth: boolean;
        supportsOauthLogin: boolean;
    }[];
    updatedAt: string;
}>;
/**
 * If a site does not exists upstream in OneGraph for the given site, create it
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} siteId The site id to create an app for upstream on OneGraph
 * @returns
 */
export declare const upsertAppForSite: (authToken: string, siteId: string) => Promise<{
    id: string;
    name: string;
    corsOrigins: string[];
    customCorsOrigins: {
        friendlyServiceName: string;
        displayName: string;
        encodedValue: string;
    }[];
}>;
/**
 * Create a new schema in OneGraph for the given site with the specified metadata (enabled services, etc.)
 * @param {string} input.netlifyToken The (typically netlify) access token that is used for authentication, if any
 * @param {object} input The details of the schema to create
 * @returns {Promise<object>} The schema metadata for the site
 */
export declare const createNewAppSchema: (nfToken: string, input: CreateNewSchemaMutationInput["input"]) => Promise<{
    id: string;
    services: {
        friendlyServiceName: string;
        logoUrl: string;
        service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";
        slug: string;
        supportsCustomRedirectUri: boolean;
        supportsCustomServiceAuth: boolean;
        supportsOauthLogin: boolean;
    }[];
}>;
/**
 * Ensure that an app exists upstream in OneGraph for the given site
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} siteId The site id to create an app for upstream on OneGraph
 * @returns
 */
export declare const ensureAppForSite: (authToken: string, siteId: string) => Promise<void>;
/**
 * Fetch a list of what services are enabled for the given site
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} appId The app id to query against
 * @returns
 */
export declare const fetchEnabledServices: (authToken: string, appId: string) => Promise<{
    friendlyServiceName: string;
    logoUrl: string;
    service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";
    slug: string;
    supportsCustomRedirectUri: boolean;
    supportsCustomServiceAuth: boolean;
    supportsOauthLogin: boolean;
}[]>;
export declare type MiniSession = {
    id: string;
    status: "ACTIVE" | "INACTIVE";
    createdAt: string;
    updatedAt: string;
};
/**
 * Mark a CLI session as active and update the session's heartbeat
 * @param {string} authToken The (typically netlify) access token that is used for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} sessionId The session id to mark as active / update heartbeat
 * @returns {errors: any[], data: MiniSession}
 */
export declare const executeMarkCliSessionActiveHeartbeat: (authToken: string, appId: string, sessionId: string) => Promise<{
    errors: import("./generatedOneGraphClient").GraphQLError[];
    data: {
        id: string;
        status: "ACTIVE" | "INACTIVE";
        createdAt: string;
        updatedAt: string;
        cliHeartbeatIntervalMs: number;
    };
}>;
/**
 * Mark a CLI session as inactive
 * @param {string} authToken The (typically netlify) access token that is used for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} sessionId The session id to mark as inactive
 * @returns {errors: any[], data: MiniSession}
 */
export declare const executeMarkCliSessionInactive: (authToken: string, appId: string, sessionId: string) => Promise<{
    errors: import("./generatedOneGraphClient").GraphQLError[];
    data: {
        id: string;
        status: "ACTIVE" | "INACTIVE";
        createdAt: string;
        updatedAt: string;
        cliHeartbeatIntervalMs: number;
    };
}>;
export {};
