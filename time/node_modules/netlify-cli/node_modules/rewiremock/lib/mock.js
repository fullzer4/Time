'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyNames = require('babel-runtime/core-js/object/get-own-property-names');

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _plugins = require('./plugins');

var _globals = require('./globals');

var _globals2 = _interopRequireDefault(_globals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ModuleMock = function () {
  function ModuleMock(mock) {
    (0, _classCallCheck3.default)(this, ModuleMock);

    this.mock = mock;
    mock._parent = this;
  }

  (0, _createClass3.default)(ModuleMock, [{
    key: 'nonStrict',
    value: function nonStrict() {
      return this;
    }
  }, {
    key: 'from',
    value: function from(source) {
      if (source instanceof ModuleMock) {
        var originalName = this.mock.name;
        (0, _assign2.default)(this.mock, source.mock);
        this.mock.name = originalName;
        this.mock._parent = this;
      } else {
        return this.with(source);
      }
    }

    /**
     * Enabled call thought original module
     * @name ModuleMock.callThrough
     * @return {ModuleMock}
     */

  }, {
    key: 'callThrough',
    value: function callThrough() {
      this.mock.allowCallThrough = true;
      return this;
    }

    /**
     * Bypass shouldMock and always mock
     */

  }, {
    key: 'always',
    value: function always() {
      this.mock.alwaysMock = true;
      return this;
    }

    /**
     * Enable automatic dependency mocking
     * @name ModuleMock.mockThrough
     * @param {Function} [mockFactory=() => emptyFunction] - mock constructor
     * @return {ModuleMock}
     */

  }, {
    key: 'mockThrough',
    value: function mockThrough() {
      var mockFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.mock.mockThrough = mockFactory;
      return this;
    }

    /**
     * Setting es6 behavior for a current module
     * @return {ModuleMock}
     */

  }, {
    key: 'es6',
    value: function es6() {
      Object.defineProperty(this.mock.value, "__esModule", {
        value: true
      });
      return this;
    }

    /**
     * Setting es6 behavior for a current module and overriding default export
     * @param stub
     * @return {ModuleMock}
     */

  }, {
    key: 'withDefault',
    value: function withDefault(stub) {
      this.with({ default: stub });
      return this.es6();
    }

    /**
     * Overriding export of a module
     * @param stubs
     * @return {ModuleMock}
     */

  }, {
    key: 'with',
    value: function _with(stubs) {
      this.mock.value = stubs;

      return this;
    }

    /**
     * Append overrides
     * @param stubs
     * @return {ModuleMock}
     */

  }, {
    key: 'append',
    value: function append(stubs) {
      if ((typeof stubs === 'undefined' ? 'undefined' : (0, _typeof3.default)(stubs)) === 'object') {
        this.mock.value = (0, _assign2.default)(this.mock.value, stubs);
      } else {
        this.mock.value = (0, _assign2.default)(stubs, this.mock.value);
      }

      return this;
    }

    /**
     * Overriding export of one module by another
     * @param {String|Function} newTarget
     * @return {ModuleMock}
     */

  }, {
    key: 'by',
    value: function by(newTarget) {
      if (typeof newTarget == 'string') {
        this.mock.overrideBy = (0, _plugins.convertName)(newTarget, (0, _globals2.default)().parentModule);
      } else {
        this.mock.overrideBy = newTarget;
      }
      return this;
    }
  }, {
    key: 'disable',
    value: function disable() {
      this.mock.disabled = true;
      return this;
    }
  }, {
    key: 'enable',
    value: function enable() {
      this.mock.disabled = false;
      return this;
    }
  }, {
    key: 'dynamic',
    value: function dynamic() {
      this.mock.flag_dynamic = true;
      return this;
    }
  }, {
    key: 'directChildOnly',
    value: function directChildOnly() {
      this.mock.flag_directChildOnly = true;
      return this;
    }
  }, {
    key: 'atAnyPlace',
    value: function atAnyPlace() {
      this.mock.flag_directChildOnly = false;
      return this;
    }
  }, {
    key: 'calledFromMock',
    value: function calledFromMock() {
      this.mock.flag_toBeCalledFromMock = true;
      return this;
    }
  }, {
    key: 'calledFromAnywhere',
    value: function calledFromAnywhere() {
      this.mock.flag_toBeCalledFromMock = false;
      return this;
    }
  }, {
    key: 'toBeUsed',
    value: function toBeUsed() {
      this.mock.flag_toBeUsed = true;
      return this;
    }
  }, {
    key: 'toMatchOrigin',
    value: function toMatchOrigin() {
      this.mock.matchOrigin = true;
      return this;
    }
  }, {
    key: 'notToBeUsed',
    value: function notToBeUsed() {
      this.mock.flag_toBeUsed = false;
      return this;
    }
  }]);
  return ModuleMock;
}();

ModuleMock.inlineConstructor = {};
(0, _getOwnPropertyNames2.default)(ModuleMock.prototype).forEach(function (key) {
  ModuleMock.inlineConstructor[key] = function () {
    var mock = new ModuleMock({ value: {} });
    return mock[key].apply(mock, arguments);
  };
});

exports.default = ModuleMock;