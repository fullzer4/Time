"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aesDecrypt = aesDecrypt;
exports.aesEncrypt = aesEncrypt;
exports.createTarballHash = createTarballHash;
exports.defaultTarballHashAlgorithm = exports.defaultAlgorithm = void 0;
exports.generateRandomHexString = generateRandomHexString;
exports.signPayload = signPayload;
exports.stringToMD5 = stringToMD5;
exports.verifyPayload = verifyPayload;

var _crypto = require("crypto");

var _jsonwebtoken = _interopRequireDefault(require("jsonwebtoken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const defaultAlgorithm = 'aes192';
exports.defaultAlgorithm = defaultAlgorithm;
const defaultTarballHashAlgorithm = 'sha1';
exports.defaultTarballHashAlgorithm = defaultTarballHashAlgorithm;

function aesEncrypt(buf, secret) {
  // deprecated (it will be migrated in Verdaccio 5), it is a breaking change
  // https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password_options
  // https://www.grainger.xyz/changing-from-cipher-to-cipheriv/
  const c = (0, _crypto.createCipher)(defaultAlgorithm, secret);
  const b1 = c.update(buf);
  const b2 = c.final();
  return Buffer.concat([b1, b2]);
}

function aesDecrypt(buf, secret) {
  try {
    // deprecated (it will be migrated in Verdaccio 5), it is a breaking change
    // https://nodejs.org/api/crypto.html#crypto_crypto_createdecipher_algorithm_password_options
    // https://www.grainger.xyz/changing-from-cipher-to-cipheriv/
    const c = (0, _crypto.createDecipher)(defaultAlgorithm, secret);
    const b1 = c.update(buf);
    const b2 = c.final();
    return Buffer.concat([b1, b2]);
  } catch (_) {
    return Buffer.alloc(0);
  }
}

function createTarballHash() {
  return (0, _crypto.createHash)(defaultTarballHashAlgorithm);
}
/**
 * Express doesn't do ETAGS with requests <= 1024b
 * we use md5 here, it works well on 1k+ bytes, but sucks with fewer data
 * could improve performance using crc32 after benchmarks.
 * @param {Object} data
 * @return {String}
 */


function stringToMD5(data) {
  return (0, _crypto.createHash)('md5').update(data).digest('hex');
}

function generateRandomHexString(length = 8) {
  return (0, _crypto.pseudoRandomBytes)(length).toString('hex');
}

async function signPayload(payload, secretOrPrivateKey, options) {
  return new Promise(function (resolve, reject) {
    return _jsonwebtoken.default.sign(payload, secretOrPrivateKey, _objectSpread({
      notBefore: '1'
    }, options), (error, token) => error ? reject(error) : resolve(token));
  });
}

function verifyPayload(token, secretOrPrivateKey) {
  return _jsonwebtoken.default.verify(token, secretOrPrivateKey);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWZhdWx0QWxnb3JpdGhtIiwiZGVmYXVsdFRhcmJhbGxIYXNoQWxnb3JpdGhtIiwiYWVzRW5jcnlwdCIsImJ1ZiIsInNlY3JldCIsImMiLCJiMSIsInVwZGF0ZSIsImIyIiwiZmluYWwiLCJCdWZmZXIiLCJjb25jYXQiLCJhZXNEZWNyeXB0IiwiXyIsImFsbG9jIiwiY3JlYXRlVGFyYmFsbEhhc2giLCJzdHJpbmdUb01ENSIsImRhdGEiLCJkaWdlc3QiLCJnZW5lcmF0ZVJhbmRvbUhleFN0cmluZyIsImxlbmd0aCIsInRvU3RyaW5nIiwic2lnblBheWxvYWQiLCJwYXlsb2FkIiwic2VjcmV0T3JQcml2YXRlS2V5Iiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwiand0Iiwic2lnbiIsIm5vdEJlZm9yZSIsImVycm9yIiwidG9rZW4iLCJ2ZXJpZnlQYXlsb2FkIiwidmVyaWZ5Il0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9jcnlwdG8tdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaCwgY3JlYXRlQ2lwaGVyLCBjcmVhdGVEZWNpcGhlciwgY3JlYXRlSGFzaCwgcHNldWRvUmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG5pbXBvcnQgeyBKV1RTaWduT3B0aW9ucywgUmVtb3RlVXNlciB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEFsZ29yaXRobSA9ICdhZXMxOTInO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRUYXJiYWxsSGFzaEFsZ29yaXRobSA9ICdzaGExJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFlc0VuY3J5cHQoYnVmOiBCdWZmZXIsIHNlY3JldDogc3RyaW5nKTogQnVmZmVyIHtcbiAgLy8gZGVwcmVjYXRlZCAoaXQgd2lsbCBiZSBtaWdyYXRlZCBpbiBWZXJkYWNjaW8gNSksIGl0IGlzIGEgYnJlYWtpbmcgY2hhbmdlXG4gIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjY3J5cHRvX2NyeXB0b19jcmVhdGVjaXBoZXJfYWxnb3JpdGhtX3Bhc3N3b3JkX29wdGlvbnNcbiAgLy8gaHR0cHM6Ly93d3cuZ3JhaW5nZXIueHl6L2NoYW5naW5nLWZyb20tY2lwaGVyLXRvLWNpcGhlcml2L1xuICBjb25zdCBjID0gY3JlYXRlQ2lwaGVyKGRlZmF1bHRBbGdvcml0aG0sIHNlY3JldCk7XG4gIGNvbnN0IGIxID0gYy51cGRhdGUoYnVmKTtcbiAgY29uc3QgYjIgPSBjLmZpbmFsKCk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtiMSwgYjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFlc0RlY3J5cHQoYnVmOiBCdWZmZXIsIHNlY3JldDogc3RyaW5nKTogQnVmZmVyIHtcbiAgdHJ5IHtcbiAgICAvLyBkZXByZWNhdGVkIChpdCB3aWxsIGJlIG1pZ3JhdGVkIGluIFZlcmRhY2NpbyA1KSwgaXQgaXMgYSBicmVha2luZyBjaGFuZ2VcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2NyeXB0b19jcnlwdG9fY3JlYXRlZGVjaXBoZXJfYWxnb3JpdGhtX3Bhc3N3b3JkX29wdGlvbnNcbiAgICAvLyBodHRwczovL3d3dy5ncmFpbmdlci54eXovY2hhbmdpbmctZnJvbS1jaXBoZXItdG8tY2lwaGVyaXYvXG4gICAgY29uc3QgYyA9IGNyZWF0ZURlY2lwaGVyKGRlZmF1bHRBbGdvcml0aG0sIHNlY3JldCk7XG4gICAgY29uc3QgYjEgPSBjLnVwZGF0ZShidWYpO1xuICAgIGNvbnN0IGIyID0gYy5maW5hbCgpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtiMSwgYjJdKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhcmJhbGxIYXNoKCk6IEhhc2gge1xuICByZXR1cm4gY3JlYXRlSGFzaChkZWZhdWx0VGFyYmFsbEhhc2hBbGdvcml0aG0pO1xufVxuXG4vKipcbiAqIEV4cHJlc3MgZG9lc24ndCBkbyBFVEFHUyB3aXRoIHJlcXVlc3RzIDw9IDEwMjRiXG4gKiB3ZSB1c2UgbWQ1IGhlcmUsIGl0IHdvcmtzIHdlbGwgb24gMWsrIGJ5dGVzLCBidXQgc3Vja3Mgd2l0aCBmZXdlciBkYXRhXG4gKiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlIHVzaW5nIGNyYzMyIGFmdGVyIGJlbmNobWFya3MuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9NRDUoZGF0YTogQnVmZmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShkYXRhKS5kaWdlc3QoJ2hleCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21IZXhTdHJpbmcobGVuZ3RoID0gOCk6IHN0cmluZyB7XG4gIHJldHVybiBwc2V1ZG9SYW5kb21CeXRlcyhsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25QYXlsb2FkKHBheWxvYWQ6IFJlbW90ZVVzZXIsIHNlY3JldE9yUHJpdmF0ZUtleTogc3RyaW5nLCBvcHRpb25zOiBKV1RTaWduT3B0aW9ucyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gand0LnNpZ24oXG4gICAgICBwYXlsb2FkLFxuICAgICAgc2VjcmV0T3JQcml2YXRlS2V5LFxuICAgICAge1xuICAgICAgICBub3RCZWZvcmU6ICcxJywgLy8gTWFrZSBzdXJlIHRoZSB0aW1lIHdpbGwgbm90IHJvbGxiYWNrIDopXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB9LFxuICAgICAgKGVycm9yLCB0b2tlbikgPT4gKGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUodG9rZW4pKVxuICAgICk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5UGF5bG9hZCh0b2tlbjogc3RyaW5nLCBzZWNyZXRPclByaXZhdGVLZXk6IHN0cmluZyk6IFJlbW90ZVVzZXIge1xuICByZXR1cm4gand0LnZlcmlmeSh0b2tlbiwgc2VjcmV0T3JQcml2YXRlS2V5KTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7Ozs7OztBQUlPLE1BQU1BLGdCQUFnQixHQUFHLFFBQXpCOztBQUNBLE1BQU1DLDJCQUEyQixHQUFHLE1BQXBDOzs7QUFFQSxTQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUFpQ0MsTUFBakMsRUFBeUQ7RUFDOUQ7RUFDQTtFQUNBO0VBQ0EsTUFBTUMsQ0FBQyxHQUFHLDBCQUFhTCxnQkFBYixFQUErQkksTUFBL0IsQ0FBVjtFQUNBLE1BQU1FLEVBQUUsR0FBR0QsQ0FBQyxDQUFDRSxNQUFGLENBQVNKLEdBQVQsQ0FBWDtFQUNBLE1BQU1LLEVBQUUsR0FBR0gsQ0FBQyxDQUFDSSxLQUFGLEVBQVg7RUFDQSxPQUFPQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxDQUFDTCxFQUFELEVBQUtFLEVBQUwsQ0FBZCxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0ksVUFBVCxDQUFvQlQsR0FBcEIsRUFBaUNDLE1BQWpDLEVBQXlEO0VBQzlELElBQUk7SUFDRjtJQUNBO0lBQ0E7SUFDQSxNQUFNQyxDQUFDLEdBQUcsNEJBQWVMLGdCQUFmLEVBQWlDSSxNQUFqQyxDQUFWO0lBQ0EsTUFBTUUsRUFBRSxHQUFHRCxDQUFDLENBQUNFLE1BQUYsQ0FBU0osR0FBVCxDQUFYO0lBQ0EsTUFBTUssRUFBRSxHQUFHSCxDQUFDLENBQUNJLEtBQUYsRUFBWDtJQUNBLE9BQU9DLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLENBQUNMLEVBQUQsRUFBS0UsRUFBTCxDQUFkLENBQVA7RUFDRCxDQVJELENBUUUsT0FBT0ssQ0FBUCxFQUFVO0lBQ1YsT0FBT0gsTUFBTSxDQUFDSSxLQUFQLENBQWEsQ0FBYixDQUFQO0VBQ0Q7QUFDRjs7QUFFTSxTQUFTQyxpQkFBVCxHQUFtQztFQUN4QyxPQUFPLHdCQUFXZCwyQkFBWCxDQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU2UsV0FBVCxDQUFxQkMsSUFBckIsRUFBb0Q7RUFDekQsT0FBTyx3QkFBVyxLQUFYLEVBQWtCVixNQUFsQixDQUF5QlUsSUFBekIsRUFBK0JDLE1BQS9CLENBQXNDLEtBQXRDLENBQVA7QUFDRDs7QUFFTSxTQUFTQyx1QkFBVCxDQUFpQ0MsTUFBTSxHQUFHLENBQTFDLEVBQXFEO0VBQzFELE9BQU8sK0JBQWtCQSxNQUFsQixFQUEwQkMsUUFBMUIsQ0FBbUMsS0FBbkMsQ0FBUDtBQUNEOztBQUVNLGVBQWVDLFdBQWYsQ0FBMkJDLE9BQTNCLEVBQWdEQyxrQkFBaEQsRUFBNEVDLE9BQTVFLEVBQXNIO0VBQzNILE9BQU8sSUFBSUMsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTRDO0lBQzdELE9BQU9DLHNCQUFJQyxJQUFKLENBQ0xQLE9BREssRUFFTEMsa0JBRks7TUFJSE8sU0FBUyxFQUFFO0lBSlIsR0FLQU4sT0FMQSxHQU9MLENBQUNPLEtBQUQsRUFBUUMsS0FBUixLQUFtQkQsS0FBSyxHQUFHSixNQUFNLENBQUNJLEtBQUQsQ0FBVCxHQUFtQkwsT0FBTyxDQUFDTSxLQUFELENBUDdDLENBQVA7RUFTRCxDQVZNLENBQVA7QUFXRDs7QUFFTSxTQUFTQyxhQUFULENBQXVCRCxLQUF2QixFQUFzQ1Qsa0JBQXRDLEVBQThFO0VBQ25GLE9BQU9LLHNCQUFJTSxNQUFKLENBQVdGLEtBQVgsRUFBa0JULGtCQUFsQixDQUFQO0FBQ0QifQ==