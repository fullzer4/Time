import { promises as fs } from 'fs';
import path from 'path';
import process from 'process';
import { execa } from 'execa';
import semver from 'semver';
import { download } from './downloader.js';
import { getPathInHome } from './home_path.js';
import { getBinaryExtension } from './platform.js';
const DENO_VERSION_FILE = 'version.txt';
const DENO_VERSION_RANGE = '^1.20.3';
class DenoBridge {
    constructor(options = {}) {
        var _a, _b, _c, _d;
        this.cacheDirectory = (_a = options.cacheDirectory) !== null && _a !== void 0 ? _a : getPathInHome('deno-cli');
        this.debug = (_b = options.debug) !== null && _b !== void 0 ? _b : false;
        this.onAfterDownload = options.onAfterDownload;
        this.onBeforeDownload = options.onBeforeDownload;
        this.useGlobal = (_c = options.useGlobal) !== null && _c !== void 0 ? _c : true;
        this.versionRange = (_d = options.versionRange) !== null && _d !== void 0 ? _d : DENO_VERSION_RANGE;
    }
    async downloadBinary() {
        if (this.onBeforeDownload) {
            this.onBeforeDownload();
        }
        await fs.mkdir(this.cacheDirectory, { recursive: true });
        this.log(`Downloading Deno CLI to ${this.cacheDirectory}...`);
        const binaryPath = await download(this.cacheDirectory, this.versionRange);
        const downloadedVersion = await DenoBridge.getBinaryVersion(binaryPath);
        // We should never get here, because it means that `DENO_VERSION_RANGE` is
        // a malformed semver range. If this does happen, let's throw an error so
        // that the tests catch it.
        if (downloadedVersion === undefined) {
            throw new Error('Could not read downloaded binary');
        }
        await this.writeVersionFile(downloadedVersion);
        if (this.onAfterDownload) {
            this.onAfterDownload();
        }
        return binaryPath;
    }
    static async getBinaryVersion(binaryPath) {
        try {
            const { stdout } = await execa(binaryPath, ['--version']);
            const version = stdout.match(/^deno ([\d.]+)/);
            if (!version) {
                return;
            }
            return version[1];
        }
        catch {
            // no-op
        }
    }
    async getCachedBinary() {
        const versionFilePath = path.join(this.cacheDirectory, DENO_VERSION_FILE);
        let cachedVersion;
        try {
            cachedVersion = await fs.readFile(versionFilePath, 'utf8');
        }
        catch {
            return;
        }
        if (!semver.satisfies(cachedVersion, this.versionRange)) {
            return;
        }
        const binaryName = `deno${getBinaryExtension()}`;
        return path.join(this.cacheDirectory, binaryName);
    }
    async getGlobalBinary() {
        if (!this.useGlobal) {
            return;
        }
        const globalBinaryName = 'deno';
        const globalVersion = await DenoBridge.getBinaryVersion(globalBinaryName);
        if (globalVersion === undefined || !semver.satisfies(globalVersion, this.versionRange)) {
            return;
        }
        return globalBinaryName;
    }
    getRemoteBinary() {
        if (this.currentDownload === undefined) {
            this.currentDownload = this.downloadBinary();
        }
        return this.currentDownload;
    }
    log(...data) {
        if (!this.debug) {
            return;
        }
        console.log(...data);
    }
    static runWithBinary(binaryPath, args, pipeOutput) {
        var _a, _b;
        const runDeno = execa(binaryPath, args);
        if (pipeOutput) {
            (_a = runDeno.stdout) === null || _a === void 0 ? void 0 : _a.pipe(process.stdout);
            (_b = runDeno.stderr) === null || _b === void 0 ? void 0 : _b.pipe(process.stderr);
        }
        return runDeno;
    }
    async writeVersionFile(version) {
        const versionFilePath = path.join(this.cacheDirectory, DENO_VERSION_FILE);
        await fs.writeFile(versionFilePath, version);
    }
    async getBinaryPath() {
        const globalPath = await this.getGlobalBinary();
        if (globalPath !== undefined) {
            this.log('Using global installation of Deno CLI');
            return { global: true, path: globalPath };
        }
        const cachedPath = await this.getCachedBinary();
        if (cachedPath !== undefined) {
            this.log('Using cached Deno CLI from', cachedPath);
            return { global: false, path: cachedPath };
        }
        const downloadedPath = await this.getRemoteBinary();
        return { global: false, path: downloadedPath };
    }
    // Runs the Deno CLI in the background and returns a reference to the child
    // process, awaiting its execution.
    async run(args, { pipeOutput } = {}) {
        const { path: binaryPath } = await this.getBinaryPath();
        return DenoBridge.runWithBinary(binaryPath, args, pipeOutput);
    }
    // Runs the Deno CLI in the background, assigning a reference of the child
    // process to a `ps` property in the `ref` argument, if one is supplied.
    async runInBackground(args, pipeOutput, ref) {
        const { path: binaryPath } = await this.getBinaryPath();
        const ps = DenoBridge.runWithBinary(binaryPath, args, pipeOutput);
        if (ref !== undefined) {
            // eslint-disable-next-line no-param-reassign
            ref.ps = ps;
        }
    }
}
export { DenoBridge };
